<51~53> 8 4 2 1
[비트 연산]
	[논리 쉬프트]
1.	쉬프트는 왼쪽(최상위비트 방향)이나 오른쪽(최하위비트 방향)으로 일어날 수 있는데, 언제나 새롭게 나오는 비트는 0이다.
	SHL, SHR명령은 각각 왼쪽, 오른쪽 shift연산을 수행한다. shift할 자리수는 상수이거나, CL레지스터에 저장된 값이어ㅑ 하며, 쉬프트된 마지막 비트는 캐리 플래그에 저장된다.
	mov ax, 0C123H ;H는 16진수라는 뜻 (1100000100100011)
	shl ax, 1; ax=8246H, CF=1 (1000001001000110)
	shr ax, 1; ax=4123H, CF=0 (0100000100100011)
	shr ax, 1; ax=2091H, CF=1 (0010000010010001)
	
	mov ax, 0C123H
	shl ax, 2; ax=048CH, CF=1
	
	mov cl 3
	shr ax, cl; ax=0091H, CF=1
2.	shift연산은 부호 없는 정수들의 빠른 곱셈과 나눗셈 연산에 자주 사용되는데, MUL이나 DIV명령에 비해 매우 빠르기 때문이다.
	부호있는 정수라면 2바이트 FFFF(-1)이 shr되면, 7FFF로 (+32,767)이 되기 때문이다. 고로 부호있는 값에서는 다른 형태의 쉬프트 연산이 사용되어야 한다.
	
	[산술 쉬프트]
3.	부호비트가 올바르게 설정 되어있다는 전제 하에 부호 있는 정수의 2의 멱수의 곱셈과 나눗셈을 위해 SAL(SHL과 동일. 부호비트가 쉬프트 연산에 의해 바뀌지 않는 이상 정확), 
	SAR(부호비트;최상위 비트를 쉬프트 하지 않고, 하위 7비트들만 shift되며, 늘 그렇듯이 마지막 shift비트는 캐리 플래그에 저장된다.)이 만들어 졌다. 
	mov as=x, 0C123H (1 100000100100011)
	sal ax, 1; ax=8246H, CF=1 (1 000001001000110)
	sal ax, 1; ax=048CH, CF=1
	sar ax, 2; ax=0123H, CF=0
	
	[회전 쉬프트]
4.	논리쉬프트처럼 작동하지만, 쉬프트를 통해 사라진 데이터가 새롭게 추가되는 데이터와 같다는 점이 차이점이다. 즉, 데이터를 하나의 순환고리로 본다. 약간 stream같넴
	ROL과 ROR은 각각 왼쪽, 오른쪽 회전을 가리키며, 마지막 쉬프트 비트를 캐리 플래그에 저장한다.
	mov ax, 0c123H; (1100000100100011)
	rol ax, 1; ax=8247H, CF=1 (1000001001000111)
	rol ax, 1; ax=048FH, CF=1
	rol ax, 1; ax=091EH, CF=0
	ror ax, 2; ax=8247H, CF=1
	ror ax, 1; ax=C123H, CF=1
	
	데이터의 비트들과 함께 캐리 플래그의 값을 회전시키는 명령들도 있는데, RCL과 RCR이다. 즉, AX레지스터가 이 명령으로 회전된다면 AX와 캐리 플래그와 함께 총 17비트가 회전되게 된다.
	mov ax, 0C123H
	clc; clear the carry flag(CF=0) ;(1100000100100011) (0)
	rcl ax, 1; ax=8246H, CF=1 (1000001001000110) (1)
	rcl ax, 1; ax=048DH, CF=1 (0000010010001101) (1)
	rcl ax, 1; ax=091BH, CF=0 (0000100100011011) (0)
	rcr ax, 2; ax=8246H, CF=1
	rcr ax, 1; ac=C123H, CF=0