<78~91>
	[다중 모듈 프로그램(multi-module program)]
1.	2개이상의 목적파일들로 구성된 프로그램을 말한다. 이들은 C드라이버 목적 파일과 어셈블리 목적 파일들로 이루어져있다.
	모듈B의 라벨을 모듈A에서 사용하기 위해선, extern지시어를 사용해야하는데, 이 라벨들이 모듈의 외부(external)에서 정의되었음을 알려준다. asm_io.inx파일은 read_int, 루틴 등등을 모두 external로 선언한다.
	 어셈블리의 라벨들은 기본적으로 외부 접근이 불가능하다. 다른 모듈에서 접근이 가능하려면 global로 전역으로 선언해야 한다. 고로 _asm_main라벨을 global로 정의하는데, global없이 C코드는 internal로 선언된 _asm_main을 참조할 수 없기에 오류를 발생시킨다.
	
	[C와 소통하기]
2.	고급언어가 이식성이 좋지만 만약 어셈블리어가 사용된다면 C에서 어셈블리 서브루틴을 호출하거나, 인라인(inline) 어셈블리를 이용하면 된다. 다만 NASM의 형식을 지원하는 컴파일러가 없다.
	어셈블리 루틴은 다음과 같은 이유로 C와 함께 사용된다.
	-C로 하기 어렵거나 매우 힘든 컴퓨터 하드웨어의 직접적인 접근
	-매우 빠르게 작동 되어야만 하는 루틴, 컴파일러가 할 수 있는 것보다도 빠르게 프로그래머가 직접 손으로 최적화를 해야 하는 부분(사실상 의미없음 컴파일러 존나 잘 최적화함)
	
	[레지스터 저장하기]
3.	C는 서브루틴이 EBX, ESI, EDI, EBP, CS, DS, SS, ES레지스터의 값을 보관한다고 생각하는데, 수정불가의 의미가 아니라 레지스터가 값을 바꾸더라도 서브루틴이 리턴할 때 이전의 값들을 복원할 수 있어야 한다는 것이다.
	특히나 EBX, ESI, EDI값들은 C가 레지스터 변수로 사용하기 때문에 반드시 변경하면 안된다. 그런데 보통 스택이 위 레지스터의 원래 값들을 저장하는데 사용한다쿠쿠루삥뽕
	
	[함수들의 라벨]
4.	대부분의 C컴파일러들은 함수나 전역/정적 변수 이름 앞에 _를 붙인다. 고로 어셈블리 루틴이 되기 위해선 라벨이 붙어야 한다. like _asm_main

	[인자 전달하기]
5.	C호출 규약의 경우, 함수 호출 시 stack에 push된 역순으로 인자들이 나타난다.
	<C의 printf("x=%d\n", x)>
	segment .data
	x dd 0
	format db "x=%d\n",0
	
	segment .text
	...
		push dword[x]
		push dword format
		call _printf
		add esp, 8
		
	;EBP+12		x의 값
	;EBP+8		형식 문자열의 주소; 형식 문자열의 주소는 항상 x의 값이전에 마지막으로 push되므로, 인자개수와 상관없이 언제나 EBP+8이다.
	;EBP+4		주소를 리턴
	;EBP		EBP를 저장
	
	[지역 변수의 주소 계산하기]
6.	data나 bss세그먼트에 정의된 라벨의 주소를 찾는 것은 링커가 알아서 다하지만, 직관적으로 스택에 저장된 지역변수나 인자의 주소를 계산하는 것은 어렵다. 우리는 서브루틴 호출 시 이 작업을 자주 한다.
	변수x(EBP-8에 위치)를 함수foo에 전달한다면,
	
	mov eax, ebp-8
	을 생각하지만, mov명령의 피연산자는 반드시 상수여야 하기에 계산을 해야하는 ebp-8은 불가능하다. 고로 LEA(Load Effective Address)를 사용한다.
	
	lea eax, [ebp-8]
	이는 EAX로 x의 주소를 계산하여 집어넣는다. LEA명령은 절대로 메모리를 읽지 않는다. 다만 다른 명령이 읽어들일 주소값을 계산하고, 이를 첫번쨰 레지스터 피연산자에 저장할 뿐이다. 고로 읽어들일 메모리 크기의 지정이 필요없다.
	
	[리턴값]
7.	void C함수가 아닌 것들은 C언어 호출규약에 따라 모든 정수형(char, int, enum, etc.)리턴값들은 EAX레지스터에 저장되어 리턴된다. 리턴값이 32비트보다 작을 경우 32비트로 확장되어 저장되며, 
	64비트값들은 EDX:EAX레지스터 쌍에 저장되고, 포인터 값또한 EAX에 저장된다. 다만 부동소수점 값들의 경우, 수치 부프로세서의 ST0레지스터에 저장된다.
	
	[다른 호출 규약]
8.	지금까지 본 80x86 C컴파일러의 C호출 규약 말고도, 컴파일러는 기본적으로 표준 호출 규약을 이용하며 여러 호출규약을 지원하는 컴파일러는 C문법을 확장하여 개개의 함수를 다른 호출규약으로 컴파일 할 수 있다.
	 GCC컴파일러는 __attribute__확장으로 개별지정이 가능한데, 표준호출규약을 이용하는 f라는 인자로 int를 가지는 void함수를 선언하려면 함수의 원형을 아래와 같이 이용하면 된다.
	
	void f(int) __attribute__((cdecl));
	
	GCC는 표준 호출(standard call)규약도 지원하는데, cdecl을 stdcall로 바꾸면 된다. 이 둘의 차이점은 stdcall은 서브루틴이 스택으로부터 인자를 제거해야한다는 것이다(like pascal) 고로 stdcall은 고정인자함수에서만 사용될 수 있다.
	GCC는 regparm라는 attribute를 지원하여 컴파일러가 스택을 사용하지 않고 레지스터를 통해 최대 3개의 정수 인자를 전달받을 수 있게 한다.
	 볼랜드와 마이크로소프트는 호출규약을 선언할 때 동일한 문법을 사용하는데, __cdecl과 __stdcall키워드를 사용한다. 
	
	void __cdecl f(int);
	
	다른 형식의 호출규약은 서브루틴의 이식성을 떨어뜨리는 반면, cdecl은 매우 단순하여 어떠한 형식의 C함수&컴파일러에서 사용할 수 있다. 대신 다른 호출규약에 비해 느릴 수 있고, 더 큰 메모리를 차지한다(함수호출시 코드에 저장된 인자를 제거해야하기에)
	stdcall은 cdecl보다 적은 메모리를 소모하며 CALL이후 스택정리의 필요가 없다. 다만 가변 개수의 인자들을 가지는 함수들에게 사용이 불가하다.
	레지스터를 이용하는 호출규약은 속도가 빠르나, 복잡하다. 인자가 레지스터, 스택 막 나뉘기에..
	
	[어셈블리에서 C함수를 호출하기]
9.	scanf는 C호출규약을 지킨다는 것을 명심하자. EBX, ESI, EDI레지스터의 값을 저장하지만, EAX, ECX, EDX레지스터의 값을 변경될 수 있다는 것이기에(사실 EAX에 scanf리턴값을 저장하기에 반드시 바뀜)
	
	segment .data
	format db "%d",0
	
	segment .text
	...
		lea eax, [ebp-16];storage for saving to eax
		push eax;backup
		push dword format;argument
		call _scanf
		add esp,8;remove argument
	...
	
	[재진입 및 재귀 서브프로그램]
10.	<재진입 서브프로그래밍의 조건>
	-재진입 서브프로그램(reetrant)는 어떠한 코드 명령도 수정하면 안된다.
	mov word[cs:$+7], 5;5를 7바이트 앞의 워드에 복사
	add ax, 2; 이전의 문장은 2에서 5로 바뀐다.
	보호모드에서는 코드세그먼트가 Read-Only이기에 첫번쨰 행은 보호모드시스템에서 중단된다. 유지, 보수도 어렵고 코드 공유도 할 수 없다.
	-전역 데이터를 수정하면 안된다. (data, bss segment data)
	<재진입 코드의 장점>
	-재귀적인 호출이 가능
	-다수의 프로세스들에 의해 공유가 가능. 여러 인스턴스가 있더라도 코드의 한 부분만이 메모리에 상주. DDL(Dynamic Link Libraries)도 이 아이디어 사용
	-multi-threaded에서 더 잘 작동한다.
	
	[재귀 서브프로그램]
11.	재귀호출은 direct 혹은 indirect호출로 나뉘어지는데, 직접재귀호출은 서브프로그램이 내부에서 스스로 호출했을 때를 일겉고, 간접재귀호출은 다른 서브프로그램이 해당 서브프로그램을 호출하기에 호출된 것을 의미한다.
	
	[C변수 저장 형식에 대하여]
12.	전역(global): 함수의 외부에서 정의되며 고정된 메모리 위치에 저장.(data나 bss세그먼트) 만약 global이 static으로 선언되어 있으면 같은 모듈에서의 함수들만이 접근 가능.(like internal not external in asm)
	정적(static): local변수인데 고정된 메모리에 상주.(data or bss) 정의되어있는 함수에서만 직접적으로 접근가능
	자동(ahtomatic): default format. stack에 할당되며 함수리턴시 스택에서 사라진다. 스택에저장되기에 고정된 메모리 위치를 갖지 않는다.
	레지스터(register): 변수의 데이터를 위해 레지스터 사용 요청함. 컴파일러가 레지스터에 안둘수도 있음. 당연히 레지스터기에 주소가 없어 참조하면 무시됨. 단순한 정수형식만이 레지스터 값이 가능함. 구조체같은건 레지스터크기에 안맞음. 종종 auto를 알아서 register로 사용
	휘발성(volatile): 컴파일러에게 변수 값이 언제든지 변경가능하다고 알려줌. 종종 컴파일러는 변수의 값을 레지스터에 두고 변수대신 사용하는데, 이러한 최적화를 없앤다. multi thread에서 언제든지 값이 변경될 수 있는 것과 비슷.
				   쉽게말해 volatile은 컴파일러가 변수를 위해 레지스터를 사용하는 것을 금지한다.