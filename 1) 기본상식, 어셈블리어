<11~46>
	[기본 상식, 키워드]
1.	최하위 비트 LSB_Least Significant Bit, 최상위 비트 MSB_Most Significant Bit
2.	nibble(4비트의 이진수), word(2바이트), double word(4바이트), quad word(8바이트), paragraph(16바이트)_B,W,D,Q,T(10바이트)
3.	8088, 8086: 1MB메모리, 실제모드, 세그먼트 최대 64KB
	80286: 16MB메모리, 16-bits protected mode, 세그먼트 최대 64KB
	80386: 4GB메모리, 32-bits protected mode, 세그먼트 최대 4GB, 기존의 16비트 레지스터들 32비트로 확장, 새 16비트 레지스터 FS, GS추가(EX처럼 임시 세그먼트)
		   명령어 하위 호환성을 위해 XH, XL을 16비트씩으로 바꾸는게 아니라 그대로 두고, EAX가 32비트 레지스터, AX가 하위 16비트레지스터를 가리키게끔 유지하였다.
		   고로 BP는 EBP 처럼 호환성때매 남겨둔 범용 빼고 모두 확장된 것으로만 사용해야 했다.
	80486/펜티엄/펜티엄 프로: 연산속도 향상
	펜티엄 MMX: MMX(MultiMedia eXtendions)명령 추가.
	펜티엄 II: 펜티엄 프로에 MMX추가
4.	범용 프로세서는 XH, XL로 나누어 독립적으로 사용가능하며, 산술 연산이나 데이터 이동에 사용
	색인 레지스터(SI, DI)는 포인터로 쓰이나 범용과 같은 기능도 가능하며, XH, XL분할이 안된다.
	포인터 레지스터(BP, SP)는 스택의 데이터위치를 가리키기 위해 사용되며, 각각 기준 포인터와 스택 포인터라 부름
	세그먼트 레지스터(CS, DS, SS, ES)는 코드, 데이타, 스택, 보조 세그먼트이다.
	명령포인터 레지스터(IP)는 CS와 함께 사용되는데, 다음 실행될 명령의 주소를 저장한다. IP는 CPU에서 명령이 실행되면 자동으로 다음 명령을 가리킨다.
	FLAG 레지스터
5.	실제모드에서 20비트의 메모리의 주소를 나타내기 위해 16비트 2개를 사용하는데, 처음 16비트를 실렉터(selector), 두번쨰 16비트를 offset
6.	세그먼트들이 4KB의 page단위로 나뉘어 작업이 가능. virtual memory에서도 segment가 아닌 page를 기준으로 작업함.
7.	event's interrpt->find address of handler in 'interrupt vector table'->interrupt handler->retore value of register before interrupt

	[어셈블리어]
1.	즉시 피연산자(immediate) is in code segment, 묵시적 피연산자(implied)는 INC에 사용되는 1같은 것으로, 정확히 나타나지 않는다.
2.	directive(지시어)는 어셈블러를 위한 것이다. symbol equ value(no redifinition), %
3.	L6 dd 1A92h
	mov al, [L6]
	L6은 더블워드(4바이트)로 초기화되어있는데, al(8비트)에 mov통래 넣고 있다. 그럼 더블워드의 하위 8비트만이 al에 들어가게 된다. mov의 피연산자는 크기가 같아야 하기 때문이다.
	이러한 이유로 정확한 라벨을 사용하는데에 집중해야 한다.
4.	어셈블리 I/O 루틴: print_int, print_char, print_string, print_nl, read_int, read_char (%include "asm_io.inc") 사용은 EAX에 적당한 값을 넣으면 된다.
	asm_io.inc 디버깅 루틴: dump_regs(구분용 정수), dump_mem(구분용 정수, 출력메모리주소, 주소뒤 출력될 패러그래프수), dump_stack(구분용 정수, EBP아래 출력할 더블워드 수, EBP위에 출력할 더블워드 수), dump_math(구분용 정수)(math copreocessor)
5.	코드를 어셈블 할 때 nasm -f object-format test.asm과 같이 ojbect-format으로 coff, elf, obj, win32등 을 넣어줘야하며, 사용할 C컴파일러에 따라 달라진다. (listing-file 스위치 -l은 주어진 이름의 리스트 파일을 생성하라고 명령하는데, 코드가 어떻게 어셈블 되었는지를 보여준다.)
	C코드를 컴파일 할때는 gcc -c driver.c처럼 링크없이 컴파일만 하게 한다. 
	목적파일 링크는 gcc -o first driver.o first.o asm_io.o 로 링크하면 된다.
	
	[정수의 표현]
1.	unsigned magnitude의 하나인 one's complement를 구하는 방법은 해당 진수의 가장 큰 값에서 각각의 원소들을 빼나가면 된다.
	부호비트->1의 보수(부호비트 자동으로 바뀜)->2의 보수(0을 하나로 표현함과 동시에 그만큼의 추가공간 존재). (p.s CPU는 type의 개념이 없기에 16진수 FF가 -1, +255 뭐로 생각될지는 프로그래머가 그 데이터에 사용하는 명령에 따라 달라진다.)
2.	unsigned의 경우, 정수 AL을 워드 AX로 확장하기 위해선 mov ah, o으로 상위 8비트를 모두 0으로 만들면 된다.
	AX에서 EAX로 늘릴때는 MOVZX를 사용하여 확장이 가능하다. movzx eax, ax; ax->eax
	 signed의 경우, CBW(Convert Bite to Word)로 AL->AX, CWD로 AX->DX:AX로 변환이 가능하다.(8086때) 
	80386에선 CWDE(Change Word to Double word Extended)로 AX->EAX가 가능하다. CDQ는 EAX->EDX:EAX(64bit)으로 확장해준다. MOVSX로 unsigned의 MOVZX와 같은 작업이 signed에서 가능하다.
	unsigned char uchar=0xFF;
	signed char schar=0xFF;
	int a=(int)uchar;//0xFF->0x000000FF
	int b=(int)schar;//0xFF->0xFFFFFFFF
3.	char ch=fgetc()의 원형은 int fgetc(FILE*)로 int로 반환하는데, EOF를 반환하기 위함이다. 다만 이 함수는 문자를 반환하기에 char에 담는순간 데이터가 잘리며 EOF가 일반 숫자혹은 문자로 바뀌어 파일 바이트 FF를 읽고있는건지 EOF를 읽는지 모르기에 int 변수로 문자를 받아야 한다.

	[2의 보수의 산술연산]
1.	add와 sub는 overflow & carry flag를 변경시킨다. 2의 보수 덕분에 signed와 unsigned은 모두 add와 sub를 사용할 수 있다.
2.	mul(unsigned)&imul(signed), div(unsigned)&idiv(unsigned). destination을 쓰지 않으면 AX, DX:AX. EDX:EAX에 연산결과가 저장된다.

	[확장 정밀도 산술 연산]
1.	ADC와 SBB를 이용한 확장 정밀도 산술 연산은, 하위를 add로 계산하고 상위를 adc로 계산하여 하위의 carry를 상위 연산에 반영하는 것이다.
	큰 수의 경우, 여러번 쪼개어 더하므로 loop를 사용할 수 있는데, 첫번째연산은 확장 정밀도 산술 연산이 아닌 일반 연산이 되어야 하므로 첫 번째 loop에서만 CLC(Carry Clear)로 ADC를 ADD처럼 작동하게 하면 된다.
	
	[비교]
1.	cmp vleft, vright-> result of "vleft-vright": [unsigned]0, ZF, CF [signed]SF=OF, ZF, SF!=OF (p.s Zero, Carry, Sign, Overflow)

	[분기(branch instruction)]
1.	jump_무조건 분기 with SHORT(128byte, use 1 signed bite for displacement), NEAR(3200byte in code segment, use 2 bite for displacement OR anywhere in code segment, use 4byte. WORD JMP NEAR: 2byte, JMP NEAR: 4byte), FAR(different code segment)
2.	JZ(ZF)&JNZ, JO(OF)&JNO, JS(SF)&JNS, JC(CF)&JNC, JP(PF)&JNP (p.s Parity flag; PF 하위 8비트 수의 홀짝성)
	
	if(EAX>=5) //>=의 경우 복잡해짐
		EBX=1;
	else 
		EBX=2;
	는
	cmp eax, 5
	js signon;(SF)
	jo elseblock;check overflow to minus->plus(OF, SF=0)
	jmp thenblock(SF=0, OF=0)
	signon:
		jo thenblock; sign=1 because of overflow
	elseblock:
		mov ebx, 2
		jmp next
	thenblock:
		mov ebx, 1
	next:
3.	JE(=), JNE(!=), JL||JNGE & JB||JNAE(<), JLE||JNG & JBE||JNZ(<=), JG||JNLE & JA||JNBE(>), JG||JNLE & JA||JNBE(>), JGE||JNL & JAE||JNB(>=) (p.s Greater&Above 초과, Below&less 미만)
	signed: greater&less, unsigned: above&below
	
	cmp eax, 5
	jge thenblock
	mov ebx, 2
	jmp next
	thenblock:
		mov ebx, 1
	next:
	
	[루프]
1.	LOOP(ECX!=0, ECX--), LOOPE&LOOPZ(ECX!=0&&ZF, ECX--), LOOPNE,LOOPNX(ECX!=0&&ZF=0, ECX--)

	[if]
1.		jxx else_block
		;then_block
		jmp endif
	else_block:
		;else_block
	endif:

	[while]
1.	while: 
		;set FLAGS
		jxx endwhile
		;body of loop
		jmp while
	endwhile:
	
	[do while]
1.	do:
		;body of loop
		;set FLAGS
		jxx do
	
	[비트연산]
1.	SHL&SHR(논리쉬프트)할 자리수는 상수이거나 CL레지스터의 저장값(ecx의 하위 8비트). unsigned의 mul, div
	mov ax, 0C123H
	shl ax,1
	mov cl, 3
	shr ax, cl
2.	SAL&SAR(산술쉬프트)에서 SAR은 부호비트는 shift하지 않음(하위 7비트만 shift). signed의 mul, div
3.	ROL&ROR(회전쉬프트)사라진 데이터가 반대쪽에 추가. RCL&RCR(회전쉬프트)인데 캐리비트까지 회전되어 AX라면 캐리플래그와 함께 17비트가 회전.
4.	SHL을 사용하여 EAX비트수 세기
		mov b1, 0
		mov ecx, 32
	count_loop:
		shl eax, 1
		jnc skip_inc;not carry flag, skip_int
		inc bl
	skip_inc:
		loop count_loop
	
	[불리언 비트 연산]
1.	inclusive(OR), exclusive(XOR), TEST는 AND연산을 수행하지만 FLAGS만 바꿀 뿐 결과를 보관하지 않는다.(CMP의 sub처럼)
2.	cl레지스터에 shift하여 임의의 비트수정이 가능하다. 키기: 1을 shift하고 or, 끄기: 1을 shift하고 not하여 and
	임의의 비트 반전은 1을 shift하고 xor

	[조건 분기 명령을 피하기(speculative execution)]
1.	SETxx는 특정 경우에 분기를 피할 목적으로 사용하는데, FLAG에 따라 바이트나 메모리의 값을 바꿔준다. SETxx의 조건이 참이면 1, 거짓이면 0이 저장되어 "setz al;ZF면 1이 al에 저장"와 같이 사용한다.

	[C에서 비트연산자 사용하기]
1.	운영체제 API들은 bit으로 data가 encode된 피연산자를 사용하는 함수를 사용하는데, POSIX 예문은 아래와 같다.
	struct stat file_stats;
	stat("foo", &file_stats);
	chmod("foo", (file_stats.st_mode&S_IOTH)|S_IRUSR);//remove S_IWOTH add S_IRUSR
	
	[빅, 리틀 엔디안 표현]
1.	리틀엔디안을 사용한 CPU표현에는 부수적인 작업이 필요하지 않다. 2바이트 AX의 AH, AL이 CPU에 어떠한 순서로 놓여있는지 모르고, 다른 메모리에 AX를 mov할때, AH를 먼저 옮기든 AL을 먼저 옮기든 옮겨지기만 하면 상관없기에 상관이 없다.
	이러한 개념이 좀 더 작은 단위의 바이트 내의 각각의 비트들에도 적용이 되는게, 바이트를 옮길 떄 옮겨지기만 하면 되기에 개개의 비트들이 CPU내부에서 어떠한 순서로 놓여있는지 알 방법도 없다.
	unsigned short word=0x1234;//sizeof(short)==2
	unsigned char *p=(unsigned char*)&word;//casting to char*
	if(p[0]==0x12)
		printf("Big Endian Machine\n");
	else
		printf("Little Endian Machine\n");
2.	엔디안 변환은 htonl(), ntohl()함수나 invert_endian함수를 직접 만들어 개개의 바이트르 역배치하자.
	80486에는 32비트 레지스터 역순을 위한 bswap edx, 16비트 레지스터를 위한 xchg ah, al(ax의 바이트를 역순으로 재배치)가 존재한다.
	
	