<111~123>
[부동소수점]
	[부동 소수점]
1.	십진법 외에 다른진법 체계에서도 정수가 아닌 수를 표현할 수 있는게, 0.101(2)=1x2^-1+0x2^-2+1x2^-3=0.625의 개념이 그대로 사용되기 때문이다.
	십진수 소수를 이진수로 바꾸려면 소수자리가 0이 될 떄까지 x2를 해주면 된다.
	0.5625 x2=1.125		first bit=1
	0.125 x2=0.25		second bit=0
	0.25 x2=0.5			third bit=0
	0.5 x2=1.0			fourth bit=1
	
	23.85를 이진수로 바꾸는 것은 정수부는 걍 바꾸면 되지만 소수부는 무한번의 연산이 필요한 순환 이진 소수 0.85이다.
	0.85x2=1.7	1
	0.7x2=1.4	1
	
	0.4x2=0.8	0
	0.8x2=1.6	1
	0.6x2=1.2	1
	0.2x2=0.4	0
	
	0.4x2=0.8	0
	0.8x2=1.6	1
	0.6x2=1.2	1
	0.2x2=0.4	0
	...
	23.85=10111.11(0110)이다.
	 즉, 23.85는 유한개의 이진 비트를 사용하여 수를 정확하게 나타낼 수 없다. 근사값만이 저장될 뿐이다.
	 
2.	하드웨어를 단순화하기 위해 부동 소수점 수들은 과학적 기수법 표현을 사용한다ㅏ. 23.85 즉, 10111.11011001100110...(2)는 1.01111101101100110...x2^100(2)로 표현된다. (여기의 2^100은 4를 나타내는 이진수 표현임)
	즉, 정규화된 부동 소수점 수는 1.ssss x 2^eeee로 나타내는데, 1.sss는 가수(significand)라 하고, eee는 지수(exponent)라 한다.(e가 0이거나 FF면 특별한 값 가짐)
	
	[IEEE부동 소수점 표현]
3.	IEEE(전기 전자 기술자 협회, Institute of Electrical and Eletronic Engineers)는 대부분의 컴퓨터 하드웨어 자체에서 지원된다. (인텔의 경우 수치 보조처리기(numeric coprocessor))
	IEEE는 정밀도가 다른 두 개의 형식 단일 정밀도(single precision_float in C), 2배 정밀도(double precision_double in C)을 지원한다. wow...
	 인텔의 수치 보조처리기는 더 높은 정밀도를 가지는 확장 정밀도(extended precision)을 사용한다. 다만 이를 메모리에 저장하 때 단일, 혹은 2배 정밀도의 수로 자동변환한다. 확장정밀도는 float이나 double에 비해 다른 형식을 사용한다.
	(확장된 정밀도는 기존의 부동 소수점 데이터 형식이 소프트웨어 기반이라는 것과 달리, 중앙 프로세서 자체에 내장되거나, FPU(floating-point unit)또는 FPP(floating-point processor)로 CPU에 엑세스 할 수 있다. 완전히 다른 방식이다.)
	
	[IEEE 단일 정밀도]
	s(31) e(30~23) f(22~0)
4.	단일 정밀도는 수를 32비트로 표현하는데, 십진수로 7자리정도 정확하다. 부동소수점은 음수를 위해 2의 보수를 사용하지 않고 부호비트를 통한 부호있는 크기 표현(signed mafnitude)을 사용한다.
	exponent는 7F를 더하여 23+30비트에 더해지기에 이 편향된 지수(biased exponent)는 언제나 음수가 아니다. significand부분은 정규화된 가수부분으로 생각하고 처리한다(1.sss)
	고로 첫번째 비트는 언제나 1이므로 1은 저장하지 않아 비트 하나를 추가적으로 저장할 수있다. 이를 숨겨진 1표현법(hidden one representation)이라고 한다.
	 이러한 방법으로 23.85가 저장되는 방법은 양수이므로 부호비트0이고, 지수가 4이므로 편향된 지수값은 7F+4=83(16)이고, 가수부분은 01111101100110011001100이다.(hidden one representation고려) 
	이들을 모두 합치면 0   100 0001 1   011 1110 1100 1100 1100 1100(2)=41BECCCC(16)이다.
	이는 당연히 순환소수이기에 23.85가 아닌 23.849998474가 되는데, C에서는 사실 이 방법을 사용하지 않고 마지막에 잘린 비트 1100 다음의 1이 1이므로 반올림하여 1100을 1101로 바꾸어 41BECCCD즉, 23.850000381로 표현하여 좀 더 정확하게 표현한다.
	 정규화된 단일 정밀도 수들은 1.0x2^-126부터 1.11111...x2^127까지 나타낼 수 있다.
5.	특정한 e와 f의 조합은 ICCC float에서 특별한 의미를 가지는데, 아래와 같다.
	<e=0, f=0>   0					(+0과 -0탓에 정규화 될 수 없다.)
	<e=0, f!=0>  정규화되지 않은 수		(다음에 자세히 다룸)
	<e=FF, f=0>  무한					(-inf와 +inf가 있을 수 있다는 거 생각하쟈..)
	<e=ff, f!=0> NaN(Not A Number)	(정의되지 않은 값 ex. 음수의 제곱근, inf+inf)
	
	[IEEE 2배 정밀도]
	s(63) e(62~52) f(51~0)
6.	64비트를 사용하며 십진수로 대략 15자리 정도 정확하다. 편향된 지수와 가수부분이 늘어났기에 편향된 지수를 구할 떄 (단일 정밀도의 7F가 아닌) 3FF(1023)을 더한다. 표현범위도 대략 10^-308~10^308이 된다. 
	23.85는 편향된 지수는 4+3FF=403(16)이니
	0	100 0000 0011	0111 1101 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001(4037D9999999999A)이 되어 23.8500000000000014가 되어 더욱 정확해진다.
	 2배 정밀도도 단일 정밀도 표현처럼 특별한 값이 있는데, 유일한 차이점은 2배 정밀도 표현에서 비정규화된 수는 2^-127이 아닌 2^-1023으로 바뀐다.
	 
	[부동 소수점 수들의 산술 연산]
7.	컴퓨터의 부동소수점 수들은 모든 수들이 정확한 값을 가진다고 생각하는 일반수학과 다르다. (이 챕터에선 단순화를 위해 8비트의 유효 숫자를 가진다고 생각해보자)
	1) 덧셈
	두 개의 부동 소수점 수들을 더학시 위해선 지수가 반드시 같아야 하기에 shift를 톨해 큰 지수에 맟추자. (이 shift에서도 사라지는 비트는 반올림)
	10.375+6.34375=16.71875를 이진법에서 수행하면
	1.0100110x2^3+1.1001011x2^2인데 shift를 통하여(반올림사용) 1.0100110x2^3+0.1100110x2^3=10.0001100x2^3이 되어 16.75로 정확한 값인 16.71875와 다른데, 덧셈 과정의 반올림에 의해 오차가 나타난 근사값이다.
	 우리가 항상 염두해야 하는 것은 컴퓨터 혹은 계산기의 부동 소수점 연산은 언제나 근사값이라는 것이다. (a+b)-b=a와 같은 수학에서의 법칙들은 절대로 컴퓨터의 부동 소수점들에 적용될 수 없다.
	2) 뺄셈
	덧셈과 마찬가지로 역으로 shift하여 계산하는데, = 16.75-15.9375=0.8125에서  0.75가 나와 근사값이라는 같은 문제가 있다.
	3) 곱셈과 나눗셈
	significand는 곱해지고, exponent는 더해진다. 
	10.375x2.5=25.9375는 1.01001100x2^3 X 1.0100000x2^1=1.10011111000000x2^4로 실제결과는 8비트로 반올림되어 1.1010000x2^4=26이라는 같은 문제를 가진다.
	 나눗셈은 더 복잡하지만 반올림으로 같은 문제를 가진다.
	
	[***프로그래밍을 위한 조언***]
8.	가장가장가장가장이 단원의 핵심적인 조언은 부동소수점 연산은 정확하지 않기에 이 점을 염두하고 제발제발제발제발제발 부동소수점을 비교하지 말라는 것이다.
	예로 f(x)함수에서 복잡한 연산을 수행하고 함수의 근(f(x)=0으로 만드는 x값)을 찾을때, 이를 확인하기 위해 우리는 
	if(f(x)==0.0)을 사용하는데, f(x)가 1.10^-30을 리턴하면 근의 좋은 근사값이지만 위의 식이 절대로 성립하지 않는다. 아마 f(x)에서의 반올림 오차로 어떠한 IEEE부동소수점 형식으로 표현된 x값도 정확히 0을 리턴하지 않을 것이다.
	 고로 위 방법대신
	if(fabs(f(x))<EPS)
	를 사용한다. EPS는 매우 작은 양수 값(1x10^-10같은)인 매크로로 정의되어 있다. 이는 통상적으로 두 개의 부동 소수점 값을 다른 값에 비교할 때 아래와 같이 사용한다.
	if(fabs(x-y)/fabs(y)<EPS)
	(정확도 더 향상! 도출된 오차값을 일반적인 오차값으로 나누어 보다 더욱 정확하게 같은지 다른지 판단)
	
[수치 부프로세서]
	[하드웨어]
9.	가장 초기의 인텔 프로세서들은 부동 소수점 연산을 지원하는 하드웨어 없이 부수적인수치 프로세서(math coprocessor)를 통해 많은 비-부동 소수점 명령들을 수행했다.
	8086/8088의 수치부프로세서는 초시프로세서보다 10배이상 빠른 속도로 명령수행이 가능했는데, 80486DX프로세서부턴 수치 부프로세서가 통합되었지만 독립적으로 떨어진 것처럼 수행된다.(초기엔 수학 부프로세서를 에뮬레이트 할 수 있는 소프트웨어로 소프트웨어 프로시저를 통해 매우 느리게 부프로세서의 역활을 이용하기도 했다)
	 수치 부프로세서에는 8개의 부동 소수점 레지스터(ST0, ST1, ST2, ... ,ST7)가 있는데, 각각 80비트의 데이터를 보관한다(80bit 확장 정밀도)
	부동 소수점 레지스터들은 주 CPU의 정수 레지스터들과는 다른 용도로 사용되는데, stack(LIFO)으로 구성되어  ST0은 항상 스택의 최상단 값을 가리켰다.
	 수피 부프로세서에는 상태 레지스터(status register)가 있어 flags를 가지는데, 비교 연산에서는 C0, C1, C2, C3 오직 4개의 플래그가 사용된다.
	
	[명령]
10.	CPU명령과 구분되에 F로 시작한다.
	1) 데이터 불러오고 저장하기
	-스택에 저장
	FLD source		메모리의 부동소수점 값을 스택 최상단에 저장. (source는 단일 혹은 2배 정밀도 값 or 부프로세서의 레지스터)
	FILD source		정수를 메모리에서 읽어 부동소수점형식으로 변환 뒤 저장 (source는 word, double word, quard word중 하나)
	FLD1			1을 저장
	FLDZ			0을 저장
	-메모리에 저장
	FST dest		ST0을 메모리에 저장. (dest는 단일 혹은 2배 정밀도 수 or 부프로세서 레지스터)
	FSTP dest		ST0을 메모리에 저장 후 pop. (dest는 단일 혹은 2배 정밀도 수 or 부프로세서 레지스터)
	FIST dest		ST0을 정수변환 뒤 메모리 저장.(dest는 word or double word) unpop이며 변화방법은 부프로세서의 제어 워드(control word)에 몇개의 비트값에 따라 달라지는데,
					이 제어워드는 가장 가까운 정수로 변환되게 초기화되어 있는데, FSTCW(저장 제어 워드 Store Control Word)와 FLDCW(불러오기 제어 워드, Load Control Word)명령을 통해 변환방법을 바꿀 수도 있다.)
	FISTP dest		FIST에서 pop이 되고, dest가 쿼드워드일수도 있다.
	-스택에서 데이터 이동, 제거
	FXCH STn		ST0과 STn의 값을 swap한다.
	FFREE STn		레지스터가 비었거나 미사용중임을 표시하여 스택에서의 레지스터의 값을 비운다.
	
	-예제_ 메모리 피연산의 크기를 확실히 지정해줘야 하는게, 어셈블러가 메모리 피연산자가 float(double word)인지 double(quard word)인지 모르기 때문이다.
	segment .bss
	array resq SIZE
	sum resq 1
	
	segment .text
		mov ecx, SIZE
		mov esi, array
		fldz;ST0=0
	lp:
		fadd qword [esi]; ST0+=*(esi)
		add esi, 8; move to next double
		loop lp
		fstp qword sum; save result to sum
	
	2) 덧셈과 뺄셈
	-ST0과 피연산자의 합을 계산하여 부프로세서 레지스터에 저장
	FASS src		ST0+=src (src는 아무거나 상관없음 단일,2배,부프레)
	FASS dest, ST0	dest+=ST0 (dest는 임의의 부프로세서 레지스터)
	FADDP dest(,ST0)dest+=ST0하고 pop (dest는 임의 부프레)
	FIADD src		ST0+=(float) src (src는 워드 or d워드)
	-두개의 피연산자에 대해 덧셈은 한가지지만, 뺄셈은 순서가 중요하기에 2가지의 서로 다른 뺄셈 명령이 존재할 수 있음(a+b=b+a지만 a-b!=b-a이기에..)
	 고로 뺄셈을 역으로 수행하는 명령의 경우 R이나 RP가 붙는다.
	FSUB src		ST0-=src (src는 부프레, 단일, 2배 수)
	FSUBR src		ST0=src-ST0 (src 부,단,2 수)
	FSUB dest, ST0	dest-=ST0 (dest는 임의의 부프레)
	FSUBR dest, ST0	dest=ST0-dest (dest는 부프레)
	FSUBP dest(,ST0)dest-=ST0후 pop (dest는 부프레)
	FSUBRP dest,(ST0)dest=ST0-dest후 pop (dest는 부프레)
	FISUB src		ST0-=(float) src ST0에서 정수를 뺀다. (src는 반드시 메모리 상의 워드 or d워드)
	FISUBR src		ST0=(float)src-ST0 ST0에서 정수를 뺸다. (src는 반드시 메모리 상의 워드 or d워드)
	
	3) 곱셈과 나눗셈
	-덧셈과 존똑
	FMUL src		ST0*=src
	FMUL dest, ST0	dest*=ST0
	FMULP dest(,ST0)dest*=ST0후 pop
	FIMUL src		ST0*=(float) src 정수곱하기
	-나눗셈은 뻴셈과 거의 존똑 0으로 나누면 무한대가 될뿐
	FDIV src		ST0/=src
	FDIVR src		STO=src/ST0
	FDIV dest, ST0	dest/=ST0
	FDIVR dest, ST0	dest=ST0/dest
	FDIVP dest(,ST0)dest/=ST0루 pop
	FDIVR dest(,ST0)dest=ST0/dest후 pop
	FIDIV src		ST0/=(float) src 정수로 나누기
	FIDIVR src		ST0=(flaot) src	정수를 ST0로 나누기
	
	4)비교
	-FCOM계열의 명령들이 부동 소수점 수에 대한 비교 명령도 수행
	FCOM src		cmp ST0 src(src부프레,단일,2배)
	FCOMP src		cmp ST0 stc후 pop
	FCOMPP			cmp ST0 ST1후 POP두번
	FICOM src		cmp ST0 (float) src
	FICOMP src		cmp ST0 (dloat) src후 pop
	FTST			cmp ST0 0
	
10.	1~4의 명령들은 부프로세서 상태 레지스터의 C0, C1, C2, C3를 바꾸는데, CPU가 이 비트에 직접접근이 불가능하기에 조건 분기 명령은 부프로세서의 상태 레지스터가 아닌 플래그 레지스터를 사용한다.
	다만, 상태 워드의 비트들을 대응되는 플래그 레지스터의 비트에 옮기는 명령들을 쉽게 이용할 수 있다.
	FSTSW dest		부프로세서의 상태 워드를 메모리의 워드나 AX레지스터에 저장
	SAHF			AH레지스터를 플래그 레지스터에 저장
	LAHF			플래그 레지스터의 비트들과 함께 AH를 불러옴
	
	;if(x>y)
	fld qword [x]; ST0=x
	fcomp qword [y]; cmp ST0 y
	fstsw ax; 부프로세서의 C비트를 flag register에 이동(전달한 비트는 두 개의 부호가 없느 정수의 비교 결과와 동일_JNA사용 이유)
	sahf
	jna else_part; flag register로 분기문
then_part:
	;part for then
	jmp end_if
else_part:
	;part for else
end_if:

	팬티엄 프로부터 이후의 프로세서들은 CPU 플래그 레지스터의 값을 직접 변경할 수 있는 명령들응 지원한다.
	FCOMI src		ST0과 src비교
	FCOMIP src		ST0와 src비교후 pop
	
	5)잡다한 명령들
	FCHS 			ST0=-ST0
	FABS 			ST0=|ST0|
	FSQRT			ST0=root(ST0)
	FSCALE 			ST0=ST0x2^ST1. ST0에 2의 멱수를 곱한다. ST1은 스택에서 제거되지 않는다.
	
	-예제_잡다한 명령 사용하여 ST0에 멱수(ST1) 빠르게 곱하기
	segment .data
	x dq 2.75; convert to double
	five dw 5
	
	segment .text
		fild dword [five]; ST0=5
		fld qword [x]; ST0=2.75, ST1=5
		fscale; ST0=2.75*32, ST1=5