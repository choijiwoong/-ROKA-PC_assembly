<67~77> 8.local varibale~다시해석해보고 목표는 110?
	[subprogram을 이용한 modular prgram & C와 같은 고급언어들과 함께 작업하기]
1.	고급언어에서의 subprogram으로는 함수와 프로시져들이 있다. calling convention, interface등을 알아보자.
	
	[간접 주소 지정]
2.	레지스터를 포인터 변수들 처럼 사용해보자. 포인터로 사용됨을 알려주기 위해서는 대괄호[]로 묶어야 한다.
	mov ax, [Data]; assign memory address of word directly.
	mov ebx, Data
	mov ax, [ebx]
	만약 AX대신 AL을 이용한다면 오직 하나의 바이트만 읽을 것이다.
	 모든 32비트 범용 레지스터(EAX, EBX, ECX, EDX)와 인덱스(ESI, EDI)레지스터들은 모두 간접 주소 지정으로 사용될 수 있다. 통상적으로 16비트와 8비트는 사용할 수 없다.
3.	서브프로그램은 다른 영역에서 쓰이는 독립적인 코드, 즉 C언어의 함수같은 것이다. 분기 명령을 통해 서브프로그램 호출이 가능하긴 하지만, 리턴시 돌아가기 위해 매우복잡해진다.
	고로 간접 형태의 JMP명령을 사용하여 레지스터에 저장된 값을 이용, 어디로 분기할 것인지 알 게 하자.
	 다만 리턴 주소 계산이 매우 복잡하다. 고로 stack을 이용하여 서브프로그램을 호출하자.
	
	[스택]
4.	대다수의 CPU는 stack을 지원하는데, 이는 LIFO리스트이다. PUSH, POP을 사용한다. 
	SS 세그먼트 레지스터는 스택을 보관할 세그먼트를 정의한다.
	ESP 레지스터는 스택으로부터 빼내질 데이터의 주소를 보관한다. 데이터는 오직 더블워드의 형태로만 저장되기에 단일 바이트를 집어넣을 수 없다.
	 PUSH명령은 ESP레지스터의 값을 4 감소시킨 수, 더블워드를 [ESP]에 위치한 더블워드에 집어 넣는다. POP명령은 [ESP]에 위치한 더블워드를 읽어들이고, ESP에 4를 더한다.
	
	push dword 1; 1이 0FFCh에 저장, ESP=0FFCh	
	push dword 2; 2가 0FF8h에 저장, ESP=0FF8h
	push dword 3; 3이 0FF4h에 저장, ESP=0FF4h
	pop eax; EAX=3, ESP=0FF8h
	pop ebx; EBX=2, ESP=0FFCh
	pop ecx; ECX=1, ESP=1000h
	스택을 통해 임시적인 데이터(parameter, local variable)을 전달하고 서브프로그램을 호출 할 수 있다.
	 80x86은 PUSHA명령을 이용하여 EAX, EBx, ECX, EDX, ESI, EDI, EBP레지스터의 값들을 모두 스택에 push할 수 있게 한다. 또한 POPA를 통해 POP이 가능하다.
	
	[CALL 과 RET 명령]
5.	CALL은 서브프로그램으로 무조건 분기 후, 실행될 명령의 주소를 스택에 push한다.  RET명령은 그 주소를 pop한 뒤, 그 주소로 점프한다.
	스택을 정확하게 관리하여 RET명령에 의해 정확한 주소 값이 POP될 수 있도록 해야한다.
	
	[호출 규약(calling conventions)]
6.	서브프로그램 호출 시, 호출 코드와 데이터 전송 방식이 같아야 하는데, 고급언어에서는 호출 규약(calling conventions)이라는 기본적인 데이터 전송 방법이 있다.
	호출 규햑은 컴파일러마다 다르고, 최적화 유무와 같은 컴파일방식에 따라서도 다를 수 있다. 단 한가지의 공통점은 CALL로 호출하고, RET으로 리턴된다는 것이다.
	 모든 PC C컴파일러는 호출규약을 지원하기에 프로그램 어떤 부분에서도 자유롭게 호출될 수 있는 재진입(reentrant) 서브 프로그램을 만들 수 있다.(서브안에서 서브 호출도 가능해짐)
	 
	[스택에 인자들을 전달하기]
7.	CALL명령 전에 인자를 스택으로 푸시하여 전달이 가능하다. C에서 처럼 서브프로그램에서 인자의 값이 바뀌지 위해서는 인자의 주소가 반드시 전달되어야 한다.
	또한 stack은 더블워드를 사용하기에 인자의 크기가 더블워드보다 작다면, 더블워드로 push전에 변환되어야 한다.
	 스택의 인자들은 pop되는 것이 아닌 스택 자체에서 접근이 가능하다 즉, 인자들은 stack에 보관함으로써 서브프로그램의 어떠한 부분에서도 인자접근이 가능하다. 
	리턴주소가 가장먼저 pop되는 문제에다가, 서브프로그램 내내 레지스터에 인자를 저장하는 것은 비효율적이므로 메모리에 저장하는 것이다. 스택에 간접 주소 지정을 사용하여 인자에 접근([ESP+4])한다.
	 그런데 서브프로그램 내에서 데이터 저장을 위해 stack을 사용하면, 인자의 위치가 ESP+4에서 ESP+8처럼 밀려나기에 접근 오류 가능성이 크다. 
	고로 80386은 EBP라는 또다른 레지스터의 사용을 가능케 했다. 이 레지스터는 스택의 데이터를 가리킨다.
	(C의 호출규약에선 EBP->ESP순으로 넣기에 서브프로그램의 끝에서 원래의 EBP값이 불러져와야한다.)
	 
	subprogram_label:
		push ebp;ebp first
		mov ebp, esp ;
	
		; subprogram code
	
		pop ebp
		ret
	(쪼매 어렵넴.. EBP이름이 맘에 안들어..)
8.	서브프로그램 종료 시, 스택에 push된 인자들은 반드시 제거되야 한다. C는 이 과정은 printf나 scanf와 같은 함수에서 가변인자를 받기에 호출자의 코드가 이를 하게 명시했지만,
	파스칼의 호출규약은 서브프로그램이 제거하라 명시했기에 가변기능을 지원하지 않는다. 마이크로소프트 읜도우즈의 API함수들도 마찬가지다.
	
	C호출 규약을 이용하는 서브프로그램의 호출 방법.
	
	push dword 1;a as argument
	call fun
	add esp, 4;remove element in stack userselp! by modifing value of stack pointer
	
	pop을 통해 인자를 스택에서 지울 수 있으나, pop된 인자; 더이상 필요없는 값이 저장된다. 대부분 많은 컴파일러들은 ADD명령이 더 많은 바이트를 사용하기에 POP ECX명령을 이용하여 인자를 제거한다. 하지만 이 역시 popped값이 ECX의 값을 바꾼다.
9.	하나의 소스파일에 여러개의 데이터와 텍스트 세그먼트들을 정의함으로써 서브 프로그램이 사용하는 데이터가 서브프로그램 근터에 정의되게 할 수 있다.

	[스택에서의 지역변수]
10.	C가 보통의 변수들(automatic)을 저장할 때, 스택을 사용하는데, 이는 recursively calling이 가능한 재진입 서브프로그램제작에 유용하다. 
	또한 C의 global, static varibale이 프로그램 종료까지 상주하는 것과는 다르게, stack은 서브프로그램이 실행될 때만 메모리에 상주한다.
	 지역변수들은 stack의 EBP다음부터 저장된다. 이들은 프로그램 서두에서 ESP로부터 필요한 바이트를 뻄으로써 할당될 수 있다.
	(하아....유레카...C98에서 변수들이 왜 함수 최상단에 몰빵되어 선언되어야 하는가....에 대한 해답.... 지역변수를 stack에 담기에 미리 크기를 구해 ESP로부터 빼놔야 한다라...)
11.	EBP레지스터는 지역 변수에 접근하기 위해 사용되는데 인자, 리턴 정보, 지역 변수를 포함한 스택의 영역을 스택 프레임(stack frame)이라고 한다. C함수를 호출할 떄 마다 스택에 새로운 스택 프레임을 생성하게 된다.
12.	프로그램의 시작과 끝 부분을 위해 만들어진 두 명령 ENTER, LEAVE명령이 사용되고 있다. ENTER은 2개의 즉시 피연산자를 가지는데, C호출 규약에서는 두번쨰 피연산자는 언제나 0이다.
	첫번쨰 인자는 지역변수가 필요로 하는 바이트 크기를 나타낸다. (ENTER과 LEAVE가 서브프로그램의 시작과끝을 간단하게 해주지만, 동일한 간단한 명령들의 모임보다 더 느리기에 자주 사용되지 않으며, 하나의 명령이 여러개의 명령보다 빠르다고 확신할 수 없음을 보여주는 예시이다.)
subprogram_label:
	enter LOCAL_BYTES, 0
	
	;subprogram code
	
	leave ret