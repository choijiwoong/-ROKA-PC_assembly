<1~24>
	[시작하기에 앞서서]
0.	Netwide Assembler, NASM 어셈블리어를 사용한다. 다른 어셈블러들로는 마이크로소프트의 MASM이나 볼랜드의 TASM이 있다. 

1.	shift나눗셈 시 가장 오른쪽 비트부터 찾아 나가는데, 이를 최하위 비트(LSB; Least significant bit)라고 부르고, 가장 왼쪽의 비트를 최상위 비트(MSB; Most sigificant bit)라고 부른다.
2.	word(2byte), double word(4byte), quard word(8byte), paragraph(16byte)라고 하며
	특히, 4비트의 이진수를 니블(nibble)이라고 하는데, 고로 16진수의 각 자리수는 1개의 nibble에 대응된다. 
3.	메모리에 있는 모든 데이터들은 수로, 문자들은 문자 코드에 대응되어 기록되는데 사실상 아스키코드는 하위 7비트만을 사용하므로 오직 128개의 서로 다른 값들만 나타낼 수 있다.(무감체의 색농도 max가 127인 이유)
4.	다른 언어로 만들어진 프로그램 언어들을 특정한 컴퓨터 아키텍쳐에 대한 기계어 코드로 소스를 바꾸어주는 프로그램을 컴파일러(compiler)라고 하는데, 각 CPU마다 특정한 기계어를 가지고 있다.
5.	CPU의 80x86계열
	-8088, 8086: 초기PC에서 사용되었다. 최대 1MB메모리만 지원되며, 여러 프로그램이 사용하고있을지도 모를 모든 메모리에 접근이 가능하기에 디버깅과 보안이 문제가 된다.
	-80286: AT계열 PC들에서 사용되었다. 16비트 보호모드를 통하여 특정 프로그램이 다른 프로그램의 메모리 접근을 막아준다.
	-80386: 크게 발전된 80286으로, 32비트 보호모드를 지원한다. 다만 세그먼트들의 크기가 커졌을 뿐, 세그먼트들에 나뉘어 프로그램이 들어간다는 것을 이전과 동일하다.
	-80486/펜티엄/펜티엄 프로: 명령들의 연산속도가 향상되었다.
	-펜티엄 MAX: 자주 실행되는 그래픽 관련 명령들의 실행 속도를 향상시키는 MMX(멀티미디어 확장, MultiMedia eXtensions)명령이 추가되었다.
	-펜티엄 II: 펜티엄 프로에 MMX명령이 추가된 프로세서이다.
	
	[보호모드와 실제모드]
6.	실제모드에선 메모리 사용이 오직 1MB로 제한된다. 고로 메모리의 주소를 나타내기 위해서 20비트가 필요한데, 8086의 레지스터는 16비트밖에 되지 않으므로 2개의 16비트 값을 사용하였다. 메모리의 물리주소16 ∗ selector + offset
7.	16을 곱하거나 뺴는 연산 시 비트연산으로 가능한데, 문제는 하나의 실렉터가 최대 64kb까지밖에 사용할 수 없기에 프로그램을 64비트 이하의 세그먼트로 쪼개야 하는데, 
	까다로울 뿐 더러 물리주소 04808이 047C:0048, 047D:0038, 047E:0028, 047B:0058등 유일한 주소값을 가지지 않기에 비교시 복잡해진다.
8.	80286의 16비트 보호모드에서의 실렉터 값을은 디스크립터 테이블(descripter tatble)의 인덱스이다. 이는 가상메모리(virtual memory)기술을 이용하는데, 실질적으로 사용하는데이터만 임시로 메모리에 두고 다른것들은
	임시적으로 디스크에 보관하여 왔다갔다하기에 세그먼트들이 메모리상의 고정 부분은 점유할 수 없다. 이는 운영체제에 의해 제어된다. 디스크립터 테이블은 시스템이 그 세그먼트에 대해 알아야 할 모든 정보가 수록되어 있다.
	 16비트 보호모드의 가장 큰 단점은 오프셋이 아직 16비트이기에 세그먼크의 크기가 64kb로 제한된다. 고로 큰 배열을 만들기 어렵다.
9.	80348의 32비트 보호모드는 오프셋이 32비트로 확장되어 오프셋의 값의 범위가 40억으로 늘어났다. 고로 세그먼트의 크기가 4GB까지 늘어났다.
	또한 세그먼트들을 작은 4KB페이지로 나눌 수 있게 되어 세그먼트 전체가 아닌 일부도 메모리에 존재할 수 있게 되었다.
	
	[인터럽트]
10.	즉각응답이 필요한 프로세스 이벤트(마우스)가 발생하면 인터럽트(interrupt)메커니즘을 통해 현재 실행되는 프로그램을 일시적으로 중지시키고, 해당 이벤트를 인터럽트 핸들러를 통과하게 한다
	CPU내부와 외부 인터럽트를 외부 인터럽트, 내부 인터럽트라 하는데, 오류 인터럽트는 트랩이라고 불린다.
	 많은 인터럽트 핸들러는 역활이 끝나면 인터럽트 전 레지스터의 저장되어 있던 값들을 모두 복원한다(일부 CPU사이클을 잃어버릴 뿐) 트랩의 경우 종종 프로그램을 종료시킨다.

	[어셈블리어]
11.	CPU들은 자기만의 기계어들(어셈블리어도 포함)을 갖고 있고, 각 명령들은 자기만의 유일한 수 코드를 갖고 있는데, 이를 연산 부호(operation code) 즉 opcode라고 부른다.
	기계어는 직업 프로그래밍하기가 힘든데, 예로 EAX와 EBX레지스터의 값을 더해 다시 EAX레지스터에 대입하는 문장은 기계어로
	03 C3
	이다. 이는 너무 이해하기 어렵기에 어셈블러(assembler)를 이용하여 
	add eax, ebx 로 나타낼 수 있다. 이는 인간이 알기 쉬운 문자열로 대응 시킨 연산 기호(mnemonic)이기에 기계어보다 쉽게 알아차릴 수 있다. 이처럼 어셈블리어의 일반적인 형식은 mnemonic operand(s)이다.
12.	보통 명령들은 0~3개의 피연산자를 갖는데, 레지스터, 메모리, 즉시 피연산자, 묵시적 피연산자가 피연산자로 올 수 있다.

	[기초 명령]
13.	move dest, src
	두 피연산자가 모두 메모리면 안된다. 또한 두 개의 피연산자 크기가 같아야 한다. 즉 AX(16bit)의 값이 BL(8bit)로 저장이 불가하다.
	
	move eax, 3; eax레지스터에 3을 대입(3은 즉시 피연산자)
	mov bx, ax; ax레지스터의 값을 bx레지스터에 대입
	
	add eax, 4; eax=eax+4
	add al, ah; al=al+ah
	
	sub bx, 10; bx=bx-10
	sub ebx, edi; ebx=ebx-edi
	
	inc ecx; ecx++ INC와 DEC의 1은 묵시적 피연산자이기에 ADD와 SUB의 기계코드의 크기보다 작다.
	dex dl; dl--

	[지시어]
14.	지시어(directive)는 CPU가 아닌 어셈블러로 하여금 무언가 하게하거나 알려주는 역활을 함으로 기계 코드로 변환되지 않는다.
	주로 상수의 정의, 저장할 메모리 정의, 메모리 세그먼트화, 조건적으로 소스의 포함, 다른 파일의 포함 등을 목적으로 한다. NASM은 C와 달리 전처리기 지시어로 %을 사용한다.
	
	symbol equ value 어셈블리 프로그래밍 시 사용되는 상수인 심볼의 정의. 심볼은 절대로 재정의될 수 없다.
	
	%define SIZE 100 C처럼 상수 매크로를 정의. 매크로는 심볼과는 다르게 재정의 될 수 있고, 단순한 수가 아니어도 되기에 좀 더 유연하다.
	mov eax, SIZE
15.	데이터 지시어들은 데이터 세그먼트에서 메모리 상의 공간을 정의하는게 사용되는데, 메모리공간 정의 방법으로 2가지 방법이 있다.
	1. 데이터만을 위한 공간을 정의 RES x(데이터크기)		2. 초기의 값들을 위한 방들을 정의 D x
	여기서 데이터 크기는 B(바이트), W(워드), D(더블워드), Q(쿼드워드), T(10바이트)이다.
	
	 메모리 위치를 라벨(label)로 표시하는것은 매우 흔한데, 라벨로 특정한 메모리 위치를 가리킬 수 있기 때문이다.
	L1 db 0; L1로 라벨링된 바이트가 0으로 초기화
	L2 dw 1000; L2라벨링 워드가 1000으로 초기화
	L3 db 110101b; L3라벨링 바이트가 2진수 110101로 초기화
	L4 db 12h; L4라벨링 바이트가 16진수 12로 초기화
	L5 db 17o; L5라벨링 바이트가 8진수 17로 초기화
	L6 dd 1A92h; L6라벨링 더블워드가 16진수 1A92로 초기화
	L7 resb 1; L7라벨링 초기화되지 않은 1바이트
	L8 db "A"; L8라벨링 바이트가 아스키코드 A(65)로 초기화. ' 과 "은 같게 취급한다.
	 위처럼 데이터가 연속적으로 정의되면 그 데이터들은 메모리 상에 연속되게 존재한다. 
	
	L9 db 0,1,2,3; 4바이트를 정의
	L10 db "w", 'o', 'r', 'd', 0; 문자열 "word"의 정의
	L11 db 'word', 0; L10과 같다.
	
	DD지시어로 정수와 단일 정밀도 부동 소수점(C의 float)상수들을 정의할 수 있지만, DQ지시어의 경우 오직 2배 정밀도 부동 소수점 상수만 정의할 수 있다.
	
	크기가 큰 것들을 위해선 NASM의 TIMES 지시어를 사용하면 되는데, 이는 피연산자를 특정한 횟수만큼 반복한다.
	L12 times 100 db 0; 10개의 (db 0)을 나열하는 것과 같다.
	L13 resw 100; 100개의 워드를 위한 공간의 정의

	[라벨]
16.	라벨의 사용 용도는 2가지로, 위와같이 데이터의 주소(즉, 오프셋)이지만, 라벨을 대괄호[]속에 사용한다면 이는 그 주소에 위치한 데이터를 나타낸다.
	즉, C언어로 비유하여 라벨이 포인터라면 대괄호는 *와 같은 역활인 것이다. 32비트 모드에서는 주소들의 크기가 32비트이다.
	mov al, [L1]; AL에 L1에 위치한 데이터를 대입한다.
	mov eax, L1; EAX에 L1에 위치한 바이트의 주소를 대입
	mov [L1], ah; L1에 위치한 바이트에 ah를 대입
	mov eax, [L6]; L6에 위치한 더블워드를 EAX에 대입
	add eax, [L6]; EAX에 L6에 위치한 더블워드
	add [L6], eax; L6에 위치한 더블워드 +=EAX
	mov al, [L6]; L6에 위치한 더블워드의 하위 비트를 AL에 대입한다.
	 맨 마지막 행에서 NASM의 중요한 특징을 알 수 있는데, 어셈블러는 라벨이 어떠한 데이터를 가리키고 있는지 전혀 신경쓰지 않기에 프로그래머가 라벨을 정확히 사용하는데에 신중을 기해야 한다.
	어셈블리어에서 데이터의 주소값을 레지스터에 저장하여 C언어의 포인터처럼 쓰는 연산이 많아지게 되는데, 이 때문에 C보다도 오류가 잦아지게 된다.
	
	mov [L6], 1;은 오류를 발생시키는데, 무엇으로 저장할지 바이트나 워드같은걸 정의하지 않았기 때문이다.
	고로 위와같은 명령은
	mov dword [L6], 1;로 한다. 즉 1을 메모리 상의 L6에서 시작하는 부분부터 더블워드로 저장하라는 것이다.
	 dword외에도 BYTE, WORD, QWORD, TWORD가 있다.