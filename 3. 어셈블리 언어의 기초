<34~39>
	[어셈블리 언어의 기초]
1.	컴퓨터 메모리에 부호있는 정수를 나타내는 방법은 대표적으로 3가지가 있으며, 모두 정수의 최상위 비트를 부호 비트(sign bit)로 사용한다. 이는 음수면 1 양수면 0의 값을 가진다.
	-부호있는 크기 표현법: 정수를 부호비트와 절댓값으로 나누어 직관적이나, 0이 +0과 -0으로 구분되며, 10에 -56이 더해지면 이를 다시 10에서 56을 뺴었다고 생각해야하기에 CPU로직이 복잡해진다.
	-1의 보수 표현법(one's complement): 이는 각 비트를 반전시키는 것으로, 첫번째 방법처럼 00000000(+0), 11111111(-0)으로 0이 2개이다. 또한 16진수의 경우 각 자리를 F에서 뻄으로써 이진수로 바꾸지 않고 보수계산이 가능하다.
	-2의 보수 표현법: 위의 2방법은 틀딱 컴퓨터에만 사용해왔다. 2의 보수는 1의 보수를 계산한 뒤 1을 더함으로써 구할 수 있다. 2의 보수를 취하는 것을 숫자에 -를 붙이는 것으로 나타내는데,
	 실제로 어떤수에게 -를 2번 취하면 원래 수로 돌아오는 것 처럼 2의 보수도 2번 취하면 원래 수로 돌아온다. MSB에서의 캐리는 무시한다.(단순히 바이트+바이트는 바이트기에)
	또한 00000000(0)에게 2의 보수를 취하면 캐리를 무시하고 다시 00000000기에 0이 하나여서 보다 간단하게 CPU로직을 만들 수 있다.
2.	어셈블리는 형(type)에 대한 개념이 없어 데이터에 어떤 명령이 사용되는지는 프로그래머에게 달려있는데, C는 signed와 unsigned를 구분함으로써 C컴파일러로 하여금
	그 데이터에 정확한 명령들을 내리게 해준다.
	
	[부호 확장]
3.	데이터를 크기를 줄이기 위해선 단순히 데이터의 가장자리 비트를 줄이면 되는데
	mov ax, 0034h;ax=52(16비트)
	mov cl, al; cl=ax의 하위 8비트
	이러한 방법은 ax에 0134h가 있는데, 위처럼 실행하면 CL이 34h가 되어 값을 잃을 것이기에 제거되는 비트들이 부호없는 정수라면 반드시 0, 부호있는 정수라면 모두 0이거나 모두 1이어야 한다.
	 또한 제거되지 않은 첫번째 비트는 반드시 제거된 비트들과 같은 값을 가져야 나중에 새로운 부호비트로써 사용될 것이다. 즉 이 남은 첫 비트가 이전의 부호비트와 같아야 한다는 것이 중요하다.
4.	데이터의 크기를 늘리려면, 부호없는 정수일 때와 있는 정수일 때와 확장시 새 비트가 달라지기에 데이터를 줄이는 것보다 조금 복잡하다.
	보통 부호없는 정수라면 새 비트가 모두 0이 되고, 부호 있는 비트라면 반드시 부호비트를 확장시켜야 한다. 위에서 언급한 것과 마찬가지로 확장된 데이터의 부호비트가 이전과 같아야한다는 점이다.
5.	80386은 부호여부에 관계없이 몇가지 수를 확장하는 명령어를 제공한다. 
	
	mov ah, o;상위 8비트들을 모두 0으로 만듬(바이트 AL을 워드 A~로 확장시키기 위해서)
	부호없는 정수들에 한하여 mov연산을 통해 상위 비트에 0을 집어넣을 수 있다. 
	
	movzx eas, as; expand ax to eax
	movzx eax, al; expand al to eax
	movzx ax, al; expand al to ax
	movzx ebx, ax; expand ax to ebx
	다만 AX의 부호없는 워드를 부호없는 더블워드 EAX에 저장하는 과정에서 EAX의 상위 16비트를 가리키는 말이 MOV명령에선 없기에 MOVZX명령을 추가하였다.
	2개의 피연산자를 가지는 명령어로, 16비트나 32비트 레지스터(as destination), 8또는 16비트 레지스터, 메모리상의 바이트나 워드(as source)이다.
6.	부호있는 정수들에 사용하는 8086의 몇가지 명령들은 CBW(byte to word)_AL->AX, SWB(word to double word)_AX->DX:AX(둘을 묶어 하나의 32비트 레지스터처럼. 8086은 32비트 레지스터가 없었다)
	CWDE(word to double word)_AX->EAX, CDQ(double word to Quard word)_EAX->EDX:EAX(64bit)
	 MOVSX명령은 부호있는 정수에 대해 MOVZX와 같은 작업을 한다.
	
	[C 프로그래밍에 응용]
7.	C에서도 부호있는/없는 정수들의 확장이 사용되는데, char ch=fgetc(fp)!=EOF코드에서 사실 fgetc의 원형은 int fgetc(FILE *)이다.
	이때 int앞에 0이 붙는 방법으로 확장되어 char형태로 반환하는데, EOF를 char형으로 표현이 불가능하기 때문이다. EOF는 16진수로 FFFFFFFF이다.
	 또한 두번째 문제는 fgetc가 int를 반환하지만 그 값이 char에 저장된다는 것으로, int의 상위 비트들을 잘라낼 것인데, 000000FF와 FFFFFFFF모두 FF로 잘려지기에
	while루프가 파일의 바이트 FF를 읽는것인지 EOF를 읽는 것인지 알 수 없게 된다.
	 결과적으로 비교시 char와 int의 EOF가 비교회는데, ch값이 int로 비교를 위해 확정된다. 이때 char이 부호가 없다면 FF가 00000FF로 확장될 것인데, 이는 EOF(FFFFFFFF)과 다르기에 무한루프가 발생한다.
	만약 char부호가 있다면 FF는 FFFFFFFF로 확장되기에 EOF에서 탈출할 수 있다. 즉, 우리는 ch변수를 char이 아닌 int로 선언해야한다.